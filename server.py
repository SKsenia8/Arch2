import socket  # Импортируем модуль для работы с сокетами, который позволяет создавать сетевые соединения
import json  # Импортируем модуль для работы с JSON


def start_server(host='127.0.0.1', port=65432): # Функция для запуска TCP-сервера
    # host: адрес, на котором будет запущен сервер '127.0.0.1' - это локальный адрес (localhost), что означает, что сервер будет доступен только на этой машине.
    # port: номер порта, на котором сервер будет слушать входящие соединения. 65432 - это произвольный порт, который не конфликтует с известными портами

    # Создаем словарь с информацией о сервере, который будет записан в файл
    server_info = {'host': host, 'port': port}

    # Открываем файл server_info.json в режиме записи ('w')
    # Если файл не существует, он будет создан. Если существует, его содержимое будет перезаписано
    with open('server_info.json', 'w') as f:
        # Сериализуем словарь server_info в формате JSON и записываем его в файл
        # Это позволяет сохранить информацию о сервере для дальнейшего использования или отладки
        json.dump(server_info, f)

    # Создаем сокет для TCP-соединения
    # socket.AF_INET указывает, что мы используем IPv4 (используется для идентификации устройств в сети с помощью адресов)
    # socket.SOCK_STREAM указывает, что мы используем TCP (ориентированный на соединение)
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Проверяем, занят ли указанный порт, пытаясь подключиться к нему
        # connect_ex возвращает 0, если соединение успешно, и код ошибки в противном случае
        result = s.connect_ex((host, port))
        if result == 0:
            # Если порт занят (результат равен 0), выводим сообщение и выходим из функции
            # Это предотвращает попытку запуска сервера на уже занятом порту
            print(f"Порт {port} уже занят.")
            return

        try:
            # Привязываем сокет к указанному адресу и порту
            # Это позволяет серверу слушать входящие соединения на этом адресе и порту
            s.bind((host, port))
            print(f"Порт {port} открыт и сервер запущен.")
        except OSError as e:
            # Если произошла ошибка при привязке (например, порт уже занят), выводим сообщение об ошибке
            print(f"Ошибка привязки порта {port}: {e}")
            return

        # Начинаем прослушивание входящих соединений
        # Метод listen() позволяет серверу принимать входящие соединения
        s.listen()
        print(f"Сервер запущен на {host}:{port}. Ожидание соединения...")

        # Принимаем входящее соединение. Метод accept() блокирует выполнение до тех пор, пока не будет установлено соединение
        conn, addr = s.accept()
        with conn:
            # Выводим информацию о подключенном клиенте (адрес и порт)
            print(f"Подключено к {addr}")
            while True:
                # Получаем данные от клиента (максимум 1024 байта)
                # Если клиент отправляет данные, они будут получены здесь
                data = conn.recv(1024)
                if not data:
                    # Если данные не получены (например, клиент закрыл соединение), выходим из цикла
                    break

                # Декодируем полученные данные из байтов в строку
                message = data.decode()
                print(f"Получено сообщение: {message}")

                # Проверяем содержимое сообщения и формируем ответ
                # Если сообщение "ping", отправляем "pong". В противном случае отправляем сообщение об ошибке
                response = "pong" if message == "ping" else "Ошибка: неизвестное сообщение"

                # Отправляем ответ клиенту, кодируя строку в байты
                conn.sendall(response.encode())
                print(f"Отправлено сообщение: {response}")


if __name__ == "__main__":
    try:
    # Запускаем сервер start_server()  # Вызываем функцию для запуска сервера с параметрами по умолчанию (localhost и порт 65432)
        start_server()
    except Exception as e:
        # Если произошла ошибка во время выполнения, выводим сообщение об ошибке
        # Это позволяет пользователю понять, что что-то пошло не так при запуске сервера
        print(f"Ошибка: {e}")
